\chapter{Software Design, Implementation and Testing}

% This could be one chapter or a few chapters. It should define and discuss the software that is developed to support the research that is being conducted. For example, if your research involves running experiments, 
% 
% What software are you creating to support that work?

\section{Requirements}
There are two main components to the software being developed for this project. The first is the manipulation of the data into a database, and the second is a web front end for the data to be accessed via. 

\section{Database}
The database has to store data for each gene that has been annotated in the dataset for each species. I decided upon this schema:

\begin{lstlisting}
  { id: Schema.ObjectId
  , hitid: String
  , species: String
  , name: String
  , cgdid: String
  , uniprot: String
  , contig: 
    { head: String
    , seq: String 
    }
  , codingseq: 
    { head: String
    , seq: String 
    }
  , protein: 
    { head: String
    , seq: String
    , goids: [String]
    , desc: String 
    }
  , codingRange: 
    { start: Number
    , end: Number
    , fail: Boolean 
    }
  }
\end{lstlisting}

This will store the unique \_id assigned by MongoDB to all documents, the ID of the hit that was found when the species coding sequences have been aligned with \textit{C. albicans}, the species it came from, the gene name and ID from Candida Genome Database, the UniProt ID, the contig of raw DNA, the coding sequence of nucleotides, the protein sequence that the coding sequence codes for, along with the annotations from NCBI nr database to provide a description, an array of Gene Ontology\cite{geneontology} ID's and finally if it can be found the positions of the start and end of the coding sequence in the raw contig. 

From this schema there are a few clear tasks of what needs to be extracted from the data that has been collated. For each alignment with \textit{C. albicans} the protein sequence and GO annotations need to found, the coding sequence that was used in the alignment and the contig that it came from. In addition to this the metadata about the genes such as the name and ID's need to be read from the mapping file that was created earlier. 

The final bit of data that needs to be added is the position of the coding sequence in the contig. A primitve algorithm will have to be developed to detect this as it is out of the scope of the project to create a 100\% accurate way of finding it.


% from blog post, may be useful later
%This was one of the more difficult parts of the project as I had to come up with a way to as efficiently as possible but as accurately as possible select the required areas in the contigs. I played around with a few ideas, but the one that stuck was arguably the most simple.
%
%By simply taking the first and last twelve bases in the coding sequence and searching for them in the contig then marking their positions, I was able to get over half of them highlighted in the contigs. Not ideal, but to get a better percentage I would have to account for any introns (non-coding regions), or use a more dynamic method of selection which would have made it much less efficient. It only takes about two minutes to import all of the genes from the three species with my chosen method.


\section{Design}
% You should concentrate on the more important aspects of the design. It is essential that an overview is presented before going into detail. As well as describing the design adopted it must also explain what other designs were considered and why they were rejected.
% 
% What design will be used?
% 
% What implementation issues are there and what testing is used? 
% 
% Even though a research project is investigating specific research questions, it is still necessary for you to discuss the software that you develop. Research has a habit of generating bits of software that can exist for several years and need future modification. Therefore you need to be able to discuss the technical issues as well as the research approach. 

The first stage in designing this system was to decide upon what database technology would be used for the data store. As discussed in the analysis a NoSQL database called MongoDB has been chosen to store the data. This choice was also influenced by the choice of server side language, which for this project will be NodeJS. 

NodeJS was chosen because 

* Client and server side languages are the same
* Integrates well with MongoDB as it uses BSON which works with native JSON
* Provides easy package management via npm
* ES6 syntax is very nice
* I have a lot of experience with it and learning a new language is outside of the scope of the project

The website for this interface will be built off of nodestack\ref{nodestack}, a set of boilerplate code that uses several technologies including:

ES6
Webpack
MongoDB
Mongoose
Travis CI
Eslint
Heroku
Pug
Stylus

http://blog.owen.cymru/nodejs-es6-boiler-plate/

% The design should describe what you expected to do, and might also explain areas that you had to revise after some investigation.

% Typically, for an object-oriented design, the discussion will focus on the choice of objects and classes and the allocation of methods to classes. The use made of reusable components should be described and their source referenced. Particularly important decisions concerning data structures usually affect the architecture of a system and so should be described here.

% How much material you include on detailed design and implementation will depend very much on the nature of the project. It should not be padded out. Think about the significant aspects of your system. For example, describe the design of the user interface if it is a critical aspect of your system, or provide detail about methods and data structures that are not trivial. Do not spend time on long lists of trivial items and repetitive descriptions. If in doubt about what is appropriate, speak to your supervisor.
 
% You should also identify any support tools that you used. You should discuss your choice of implementation tools - programming language, compilers, database management system, program development environment, etc.

% Some example sub-sections may be as follows, but the specific sections are for you to define. 

\subsection{Overall Architecture}

\subsection{Some detailed design}

\subsubsection{Even more detail}

\subsection{User Interface}

\subsection{Other relevant sections}

\section{Implementation}

% This section should discuss issues you encountered as you tried to implement your experiments. What were the results of running the experiments? What conclusions can you draw from these results? 
% 
% During the work, you might have found that elements of your experiments were unnecessary or overly complex; perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?
% 
% It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant? 
% 
% If you had multiple experiments to run, it may be sensible to discuss each experiment in separate sections. 

\section{Testing}
% Detailed descriptions of every test case are definitely not what is required here. What is important is to show that you adopted a sensible strategy that was, in principle, capable of testing the system adequately even if you did not have the time to test the system fully.

% Provide information in the body of your report and the appendix to explain the testing that has been performed. How does this testing address the requirements and design for the project?

% How comprehensive is the testing within the constraints of the project?  Are you testing the normal working behaviour? Are you testing the exceptional behaviour, e.g. error conditions? Are you testing security issues if they are relevant for your project? 

% Have you tested your system on ``real users''? For example, if your system is supposed to solve a problem for a business, then it would be appropriate to present your approach to involve the users in the testing process and to record the results that you obtained. Depending on the level of detail, it is likely that you would put any detailed results in an appendix.

% The following sections indicate some areas you might include. Other sections may be more appropriate to your project. 

\subsection{Overall Approach to Testing}

\subsection{Automated Testing}

\subsubsection{Unit Tests}

\subsubsection{User Interface Testing}

\subsubsection{Stress Testing}

\subsubsection{Other types of testing}

\subsection{Integration Testing}

\subsection{User Testing}
